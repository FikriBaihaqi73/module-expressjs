# Pekan 4 - Hari 19: Object Oriented Programming (OOP)

**HARI KE-19** â€“ Struktur & Modularitas  
**Fokus hari ini:** Memahami dan menerapkan konsep OOP untuk membuat kode yang lebih terstruktur, maintainable, dan scalable.

---

## 1. Pengenalan OOP (Object Oriented Programming)

OOP adalah paradigma pemrograman yang berorientasi pada **Object**. Jika sebelumnya kita banyak menggunakan function (Functional Programming style), sekarang kita akan membungkus logika dan data ke dalam **Class**.

### Mengapa OOP?

**Keuntungan OOP:**
- **Encapsulation**: Mengamankan data dan logika internal, mencegah akses tidak sah
- **Inheritance**: Mewariskan sifat/method dari parent class, mengurangi duplikasi kode
- **Polymorphism**: Satu interface, banyak bentuk implementasi
- **Abstraction**: Menyembunyikan kompleksitas detail implementasi
- **Reusability**: Code dapat digunakan kembali dengan mudah
- **Maintainability**: Lebih mudah untuk debug dan update kode

**Kapan Menggunakan OOP?**
- Aplikasi dengan business logic yang kompleks
- Ketika butuh struktur yang jelas dan terorganisir
- Proyek dengan banyak entity yang saling berinteraksi
- Ketika ingin memisahkan concerns (Separation of Concerns)

---

## 2. Konsep Dasar di TypeScript

### 2.1 Class & Object

Class adalah cetakan (blueprint), Object adalah hasil cetakannya (instance).

```ts
class Mobil {
  merk: string;
  warna: string;
  tahun: number;

  constructor(merk: string, warna: string, tahun: number) {
    this.merk = merk;
    this.warna = warna;
    this.tahun = tahun;
  }

  jalan() {
    console.log(`${this.merk} berwarna ${this.warna} sedang berjalan...`);
  }

  deskripsi() {
    return `${this.merk} ${this.warna} tahun ${this.tahun}`;
  }
}

// Membuat instance (Object)
const avanza = new Mobil('Toyota Avanza', 'Hitam', 2023);
const brio = new Mobil('Honda Brio', 'Putih', 2024);

avanza.jalan(); // Toyota Avanza berwarna Hitam sedang berjalan...
console.log(brio.deskripsi()); // Honda Brio Putih tahun 2024
```

### 2.2 Encapsulation (Access Modifiers)

Mengontrol siapa yang boleh mengakses properti/method.

**Access Modifiers:**
- `public`: Bisa diakses dari mana saja (default)
- `private`: Hanya bisa diakses dari dalam class itu sendiri
- `protected`: Bisa diakses dari class itu sendiri dan class turunannya

```ts
class AkunBank {
  private saldo: number;
  public pemilik: string;
  protected nomorRekening: string;

  constructor(pemilik: string, nomorRekening: string, saldoAwal: number) {
    this.pemilik = pemilik;
    this.nomorRekening = nomorRekening;
    this.saldo = saldoAwal;
  }

  // Getter untuk mengakses private property
  cekSaldo(): number {
    return this.saldo;
  }

  // Setter untuk memodifikasi dengan validasi
  deposit(jumlah: number): void {
    if (jumlah <= 0) {
      throw new Error('Jumlah deposit harus lebih dari 0');
    }
    this.saldo += jumlah;
  }

  tarik(jumlah: number): void {
    if (jumlah > this.saldo) {
      throw new Error('Saldo tidak cukup');
    }
    this.saldo -= jumlah;
  }
}

const akun = new AkunBank('John Doe', '1234567890', 1000);
console.log(akun.pemilik); // OK: public
console.log(akun.cekSaldo()); // OK: menggunakan method
// console.log(akun.saldo); // ERROR: private
// console.log(akun.nomorRekening); // ERROR: protected

akun.deposit(500);
console.log(akun.cekSaldo()); // 1500
```

### 2.3 Inheritance (Pewarisan)

Inheritance memungkinkan class untuk mewarisi properties dan methods dari class lain.

```ts
// Parent class (Base class)
class Kendaraan {
  protected merk: string;
  protected tahun: number;

  constructor(merk: string, tahun: number) {
    this.merk = merk;
    this.tahun = tahun;
  }

  info(): string {
    return `${this.merk} tahun ${this.tahun}`;
  }

  jalan(): void {
    console.log(`${this.merk} sedang berjalan`);
  }
}

// Child class (Derived class)
class Motor extends Kendaraan {
  private jenisMotor: string;

  constructor(merk: string, tahun: number, jenisMotor: string) {
    super(merk, tahun); // Memanggil constructor parent
    this.jenisMotor = jenisMotor;
  }

  // Override method dari parent
  info(): string {
    return `${super.info()} - Jenis: ${this.jenisMotor}`;
  }

  // Method khusus untuk Motor
  wheelie(): void {
    console.log(`${this.merk} melakukan wheelie!`);
  }
}

const motor = new Motor('Yamaha', 2023, 'Sport');
console.log(motor.info()); // Yamaha tahun 2023 - Jenis: Sport
motor.jalan(); // Method dari parent
motor.wheelie(); // Method sendiri
```

### 2.4 Abstract Classes

Abstract class tidak bisa di-instantiate langsung, hanya sebagai blueprint untuk class lain.

```ts
abstract class Shape {
  abstract hitungLuas(): number;
  abstract hitungKeliling(): number;

  // Concrete method (boleh ada di abstract class)
  deskripsi(): string {
    return `Luas: ${this.hitungLuas()}, Keliling: ${this.hitungKeliling()}`;
  }
}

class Lingkaran extends Shape {
  constructor(private radius: number) {
    super();
  }

  hitungLuas(): number {
    return Math.PI * this.radius ** 2;
  }

  hitungKeliling(): number {
    return 2 * Math.PI * this.radius;
  }
}

class PersegiPanjang extends Shape {
  constructor(private panjang: number, private lebar: number) {
    super();
  }

  hitungLuas(): number {
    return this.panjang * this.lebar;
  }

  hitungKeliling(): number {
    return 2 * (this.panjang + this.lebar);
  }
}

const lingkaran = new Lingkaran(7);
const persegi = new PersegiPanjang(5, 10);

console.log(lingkaran.deskripsi());
console.log(persegi.deskripsi());
```

### 2.5 Interfaces

Interface mendefinisikan struktur yang harus diikuti oleh class.

```ts
interface IUser {
  id: number;
  name: string;
  email: string;
  getFullInfo(): string;
}

interface IAuthenticatable {
  login(password: string): boolean;
  logout(): void;
}

// Class bisa implement multiple interfaces
class User implements IUser, IAuthenticatable {
  constructor(
    public id: number,
    public name: string,
    public email: string,
    private password: string
  ) {}

  getFullInfo(): string {
    return `${this.name} (${this.email})`;
  }

  login(password: string): boolean {
    return this.password === password;
  }

  logout(): void {
    console.log(`${this.name} telah logout`);
  }
}
```

---

## 3. Implementasi OOP di Express

Mari kita refactor Express app menggunakan OOP pattern yang proper dengan layered architecture.

### 3.1 Struktur Folder (Layered Architecture)

```
src/
  â”œâ”€â”€ controllers/      # Handle HTTP requests
  â”œâ”€â”€ services/         # Business logic
  â”œâ”€â”€ repositories/     # Database operations
  â”œâ”€â”€ models/           # Data models & interfaces
  â”œâ”€â”€ middlewares/      # Express middlewares
  â”œâ”€â”€ routes/           # Route definitions
  â””â”€â”€ utils/            # Helper functions
```

### 3.2 Interface/Model Layer

```ts
// src/models/product.model.ts
export interface IProduct {
  id: number;
  name: string;
  price: number;
  stock: number;
  createdAt: Date;
}

export interface ICreateProduct {
  name: string;
  price: number;
  stock: number;
}

export interface IUpdateProduct {
  name?: string;
  price?: number;
  stock?: number;
}
```

### 3.3 Repository Layer (Data Access)

```ts
// src/repositories/product.repository.ts
import { IProduct, ICreateProduct, IUpdateProduct } from '../models/product.model';

export class ProductRepository {
  // Simulasi database (ganti dengan real DB connection)
  private products: IProduct[] = [];
  private currentId = 1;

  async findAll(): Promise<IProduct[]> {
    return this.products;
  }

  async findById(id: number): Promise<IProduct | undefined> {
    return this.products.find(p => p.id === id);
  }

  async create(data: ICreateProduct): Promise<IProduct> {
    const newProduct: IProduct = {
      id: this.currentId++,
      ...data,
      createdAt: new Date()
    };
    this.products.push(newProduct);
    return newProduct;
  }

  async update(id: number, data: IUpdateProduct): Promise<IProduct | null> {
    const index = this.products.findIndex(p => p.id === id);
    if (index === -1) return null;

    this.products[index] = {
      ...this.products[index],
      ...data
    };
    return this.products[index];
  }

  async delete(id: number): Promise<boolean> {
    const index = this.products.findIndex(p => p.id === id);
    if (index === -1) return false;

    this.products.splice(index, 1);
    return true;
  }
}
```

### 3.4 Service Layer (Business Logic)

```ts
// src/services/product.service.ts
import { ProductRepository } from '../repositories/product.repository';
import { IProduct, ICreateProduct, IUpdateProduct } from '../models/product.model';

export class ProductService {
  private repository: ProductRepository;

  constructor(repository: ProductRepository) {
    this.repository = repository;
  }

  async getAllProducts(): Promise<IProduct[]> {
    return await this.repository.findAll();
  }

  async getProductById(id: number): Promise<IProduct> {
    const product = await this.repository.findById(id);
    if (!product) {
      throw new Error(`Product with id ${id} not found`);
    }
    return product;
  }

  async createProduct(data: ICreateProduct): Promise<IProduct> {
    // Business logic: validasi
    if (data.price <= 0) {
      throw new Error('Price must be greater than 0');
    }
    if (data.stock < 0) {
      throw new Error('Stock cannot be negative');
    }

    return await this.repository.create(data);
  }

  async updateProduct(id: number, data: IUpdateProduct): Promise<IProduct> {
    const product = await this.repository.update(id, data);
    if (!product) {
      throw new Error(`Product with id ${id} not found`);
    }
    return product;
  }

  async deleteProduct(id: number): Promise<void> {
    const deleted = await this.repository.delete(id);
    if (!deleted) {
      throw new Error(`Product with id ${id} not found`);
    }
  }

  async checkStock(id: number): Promise<boolean> {
    const product = await this.getProductById(id);
    return product.stock > 0;
  }
}
```

### 3.5 Controller Layer (HTTP Handling)

```ts
// src/controllers/product.controller.ts
import { Request, Response, NextFunction } from 'express';
import { ProductService } from '../services/product.service';

export class ProductController {
  private productService: ProductService;

  constructor(productService: ProductService) {
    this.productService = productService;
  }

  // Arrow function untuk binding 'this' otomatis
  getProducts = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const products = await this.productService.getAllProducts();
      res.json({
        success: true,
        data: products
      });
    } catch (error) {
      next(error);
    }
  }

  getProduct = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const id = parseInt(req.params.id);
      const product = await this.productService.getProductById(id);
      res.json({
        success: true,
        data: product
      });
    } catch (error) {
      next(error);
    }
  }

  createProduct = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const product = await this.productService.createProduct(req.body);
      res.status(201).json({
        success: true,
        data: product,
        message: 'Product created successfully'
      });
    } catch (error) {
      next(error);
    }
  }

  updateProduct = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const id = parseInt(req.params.id);
      const product = await this.productService.updateProduct(id, req.body);
      res.json({
        success: true,
        data: product,
        message: 'Product updated successfully'
      });
    } catch (error) {
      next(error);
    }
  }

  deleteProduct = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const id = parseInt(req.params.id);
      await this.productService.deleteProduct(id);
      res.json({
        success: true,
        message: 'Product deleted successfully'
      });
    } catch (error) {
      next(error);
    }
  }
}
```

### 3.6 Route Configuration

```ts
// src/routes/product.route.ts
import { Router } from 'express';
import { ProductController } from '../controllers/product.controller';
import { ProductService } from '../services/product.service';
import { ProductRepository } from '../repositories/product.repository';

const router = Router();

// Dependency Injection pattern
const productRepository = new ProductRepository();
const productService = new ProductService(productRepository);
const productController = new ProductController(productService);

router.get('/products', productController.getProducts);
router.get('/products/:id', productController.getProduct);
router.post('/products', productController.createProduct);
router.put('/products/:id', productController.updateProduct);
router.delete('/products/:id', productController.deleteProduct);

export default router;
```

### 3.7 Main App Setup

```ts
// src/app.ts
import express from 'express';
import productRoutes from './routes/product.route';

const app = express();

app.use(express.json());
app.use('/api', productRoutes);

// Error handling middleware
app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error(err.stack);
  res.status(500).json({
    success: false,
    message: err.message || 'Internal server error'
  });
});

export default app;
```

---

## 4. Best Practices & Tips

### 4.1 Dependency Injection

Jangan hardcode dependencies di dalam class. Pass dependencies melalui constructor.

```ts
// âŒ Bad: Hardcoded dependency
class UserService {
  private repository = new UserRepository(); // Tightly coupled
}

// âœ… Good: Dependency injection
class UserService {
  constructor(private repository: UserRepository) {} // Loosely coupled
}
```

### 4.2 Single Responsibility Principle (SRP)

Setiap class harus punya satu tanggung jawab saja.

```ts
// âŒ Bad: Terlalu banyak tanggung jawab
class UserManager {
  validateUser() {}
  saveToDatabase() {}
  sendEmail() {}
  generateReport() {}
}

// âœ… Good: Terpisah berdasarkan tanggung jawab
class UserValidator {
  validate() {}
}
class UserRepository {
  save() {}
}
class EmailService {
  send() {}
}
class ReportGenerator {
  generate() {}
}
```

### 4.3 Composition Over Inheritance

Lebih baik gunakan composition daripada inheritance chain yang panjang.

```ts
// Composition example
class Logger {
  log(message: string) {
    console.log(`[LOG]: ${message}`);
  }
}

class DatabaseService {
  constructor(private logger: Logger) {}

  query() {
    this.logger.log('Executing query...');
    // query logic
  }
}
```

---

## 5. Tugas Harian Hari Ke-19

**Misi:** Refactor aplikasi Express Anda menjadi architecture dengan OOP pattern.

### Task 1: Persiapan Struktur (30 menit)
- [ ] Buat struktur folder layered architecture
- [ ] Pindahkan file-file ke folder yang sesuai

### Task 2: Implementasi Layer (2 jam)
- [ ] Buat interface/model untuk entity Anda (User, Product, dll)
- [ ] Buat Repository class untuk database operations
- [ ] Buat Service class untuk business logic
- [ ] Buat Controller class untuk HTTP handling

### Task 3: Refactor Routes (30 menit)
- [ ] Refactor routes untuk menggunakan Controller classes
- [ ] Implement dependency injection pattern

### Task 4: Testing (1 jam)
- [ ] Test semua endpoints dengan Postman/Thunder Client
- [ ] Pastikan semua CRUD operations berfungsi
- [ ] Test error handling

### Bonus Challenges:
- [ ] Implementasi Abstract class untuk Repository
- [ ] Buat Base Controller class dengan common methods
- [ ] Tambahkan interface untuk semua Services
- [ ] Implement middleware sebagai class

---

## 6. Checklist Pembelajaran

**Konsep Dasar:**
- [ ] Memahami perbedaan Class dan Object
- [ ] Mengerti Access Modifiers (public, private, protected)
- [ ] Memahami Inheritance dan cara menggunakannya
- [ ] Mengerti kapan menggunakan Abstract class vs Interface

**Praktik:**
- [ ] Berhasil membuat minimal satu Controller menggunakan Class
- [ ] Memisahkan logic ke Service class
- [ ] Membuat Repository untuk data access
- [ ] Menggunakan Dependency Injection

**Architecture:**
- [ ] Memahami Layered Architecture
- [ ] Menerapkan Separation of Concerns
- [ ] Mengikuti SOLID principles (minimal SRP)

---

## 7. Resources & Next Steps

**Untuk Dipelajari Lebih Lanjut:**
- SOLID Principles (terutama untuk OOP yang lebih advanced)
- Design Patterns (Singleton, Factory, Strategy, dll)
- Dependency Injection Containers (seperti TypeDI, InversifyJS)
- Unit Testing dengan OOP (mocking dependencies)

**Tips Penting:**
- OOP sangat powerful ketika aplikasi semakin besar
- Jangan over-engineer untuk aplikasi kecil
- Start simple, refactor when needed
- Code readability > Code complexity

---

**Selamat belajar! Dengan OOP, code Anda akan lebih terstruktur, mudah di-test, dan mudah di-maintain. ðŸš€**