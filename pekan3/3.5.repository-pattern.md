# Pekan 3 - Hari 17: Repository Pattern & Service Layer

**HARI KE-17** ‚Äì Arsitektur Bersih (Clean Architecture)
**Fokus hari ini:** Memisahkan tanggung jawab kode menjadi 3 lapisan (Repository, Service, Controller) agar `be/src/` rapi, scalable, dan mudah di-test.

---

## 1. Masalah: Business Logic & Query Bercampur

Saat ini di kode kita (Service Layer Pattern sederhana), Service seringkali melakukan terlalu banyak hal:
1.  Menerima logika bisnis.
2.  Menulis query database (Prisma) secara detail (`findMany`, `include`, `where`).

Jika kita ingin mengganti database (misal dari Postgres ke Mongo) atau ORM (dari Prisma ke TypeORM), kita harus membongkar file Service yang penuh logika bisnis.

**Solusi:** Pindahkan urusan "query database" ke layer khusus bernama **Repository**.

---

## 2. Arsitektur 3 Layer (The Standard)

Kita akan membagi kode menjadi 3 lapisan tugas yang spesifik:

1.  **Repository Layer:** "Tukang Ambil Data". Hanya berisi query ke database. Tidak peduli validasi atau bisnis.
2.  **Service Layer:** "Otak Bisnis". Berisi validasi, kalkulasi, dll. Dia minta data ke Repository.
3.  **Controller Layer:** "Resepsionis HTTP". Terima request, validasi input body/params, panggil Service, kirim JSON.

### Diagram Alur
`Client` -> `Route` -> `Controller` -> `Service` -> `Repository` -> `Database`

---

## 3. Implementasi Kode

Berikut adalah contoh perubahan kode pada fitur **Product** (`src/repositories/product.repository.ts`).

### A. Layer 1: Repository (`src/repositories/product.repository.ts`)
Tugas: Bungkus fungsi Prisma.

```ts
import prisma from '../prisma';
import type { Product, Prisma } from '../generated/client';

export const findAll = async (skip: number, take: number, where: Prisma.ProductWhereInput, orderBy: Prisma.ProductOrderByWithRelationInput) => {
  return await prisma.product.findMany({
    skip,
    take,
    where,
    orderBy,
    include: { category: true } // Relation selalu diurus di repo atau service sesuai kebutuhan
  });
};

export const countAll = async (where: Prisma.ProductWhereInput) => {
  return await prisma.product.count({ where });
};

export const findById = async (id: number) => {
  return await prisma.product.findUnique({
    where: { id, deletedAt: null },
    include: { category: true }
  });
};

export const create = async (data: Prisma.ProductCreateInput) => {
  return await prisma.product.create({ data });
};

export const update = async (id: number, data: Prisma.ProductUpdateInput) => {
  return await prisma.product.update({
    where: { id },
    data 
  });
};

export const softDelete = async (id: number) => {
  return await prisma.product.update({
    where: { id },
    data: { deletedAt: new Date() }
  });
};
```

### B. Layer 2: Service (`src/services/product.service.ts`)
Tugas: Otak bisnis. Panggil Repository, jangan panggil `prisma` langsung!

```ts
import * as productRepo from '../repositories/product.repository';
import type { Product } from '../generated/client';

interface findAllParams {
  page: number;
  limit: number;
  search?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export const getAllProducts = async (params: findAllParams) => {
  const { page, limit, search, sortBy, sortOrder } = params;
  const skip = (page - 1) * limit;

  // Logic filter (Where Clause) disiapkan di Service
  const whereClause: any = {
    deletedAt: null 
  };
  if (search) {
    whereClause.name = { contains: search, mode: 'insensitive' };
  }
  
  const sortCriteria = sortBy ? { [sortBy]: sortOrder || 'desc' } : { createdAt: 'desc' };

  // Panggil Repository (BUKAN Prisma langsung)
  const products = await productRepo.findAll(skip, limit, whereClause, sortCriteria);
  const totalItems = await productRepo.countAll(whereClause);

  return {
    products,
    totalItems,
    totalPages: Math.ceil(totalItems / limit),
    currentPage: page
  };
};

export const createProduct = async (data: any) => {
  // Business Logic: Validasi stok tidak boleh minus, dll bisa disini
  if (data.stock < 0) throw new Error("Stock cannot be negative");

  return await productRepo.create(data);
};

// ... fungsi update dan delete memanggil repo terkait
```

### C. Layer 3: Controller (`src/controllers/product.controller.ts`)
Tugas: Terima Request, Panggil Service. (Kode Controller biasanya tidak berubah banyak dari materi sebelumnya, hanya saja Service yang dipanggil sekarang lebih bersih).

```ts
// Sama seperti materi sebelumnya
import * as ProductService from '../services/product.service';

export const getProducts = async (req: Request, res: Response) => {
   // ... ambil query params
   const result = await ProductService.getAllProducts({ ... });
   // ... kirim response
}
```

---

## 4. Tugas Harian: Refactor ke Repository Pattern

**Misi:** Ubah kode `be/src` kamu agar sepenuhnya menerapkan pola ini.

1.  **Buat Folder:** Pastikan ada folder `src/repositories`.
2.  **Product Repository:** Buat file `src/repositories/product.repository.ts`. Pindahkan semua codingan `prisma.product...` dari Service ke sini.
3.  **Product Service:** Ubah `src/services/product.service.ts` agar meng-import repository, bukan prisma.
4.  **Ulangi:** Lakukan hal yang sama untuk fitur **Category** dan **Auth** (User) jika sempat.

**Mengapa repot-repot begini?**
Agar saat kalian kerja di perusahaan besar (Enterprise), kalian tidak kaget. Struktur ini sangat umum digunakan di NestJS, Java Spring Boot, dan framework backend besar lainnya.

**Checklist Penilaian:**
- [ ] Folder `repositories` tercipta.
- [ ] File Service tidak ada yang import `prisma` langsung (kecuali untuk transaction cases tertentu).
- [ ] Semua fitur CRUD Product berjalan normal tanpa error.

---
Semangat Refactor! üõ†Ô∏è
