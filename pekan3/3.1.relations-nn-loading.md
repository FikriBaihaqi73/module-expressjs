# Pekan 3 - Hari 13: Relasi Many-to-Many & Eager Loading

**HARI KE-13** â€“ Hubungan yang Kompleks
**Fokus hari ini:** Menangani relasi Banyak-ke-Banyak (N-N) dan mengambil data relasi dengan efisien dalam arsitektur MVC.

---

## 1. Konsep Many-to-Many (N-N)

Contoh kasus: **Transaksi Belanja**.
- 1 Transaksi bisa berisi BANYAK Produk.
- 1 Produk bisa ada di BANYAK Transaksi.

Di database, kita tidak bisa menyimpan ini secara langsung. Kita butuh **Tabel Penghubung (Pivot Table)**, biasanya bernama `TransactionItems` atau `OrderDetails`.

---

## 2. Implementasi di Prisma

Kita akan buat sistem Checkout sederhana.

### Update Schema

Karena project ini menggunakan **Prisma Multi-Schema** (file terpisah), kita akan memecah modelnya.

#### 1. Buat `src/prisma/schema/User.prisma`
```prisma
model User {
  id           Int           @id @default(autoincrement())
  name         String
  email        String        @unique
  transactions Transaction[]
  
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  deletedAt    DateTime?     @db.Timestamptz

  @@map("users")
}
```

#### 2. Update `src/prisma/schema/Product.prisma`
Tambahkan relasi `transactionItems` ke model Product yang sudah ada.

```prisma
model Product {
  // ... field yang sudah ada (id, name, price, dll) ...
  
  transactionItems TransactionItem[] // TAmbahkan baris ini

  // ...
}
```

#### 3. Buat `src/prisma/schema/Transaction.prisma`
Simpan model Transaction dan pivot-nya di sini.

```prisma
model Transaction {
  id        Int               @id @default(autoincrement())
  userId    Int
  user      User              @relation(fields: [userId], references: [id])
  total     Decimal           @db.Decimal(10, 2)
  items     TransactionItem[] 
  
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  deletedAt DateTime?         @db.Timestamptz

  @@map("transactions")
}

// Tabel Pivot (Penghubung)
model TransactionItem {
  id            Int         @id @default(autoincrement())
  transactionId Int
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  productId     Int
  product       Product     @relation(fields: [productId], references: [id])
  quantity      Int
  priceAtTime   Decimal     @db.Decimal(10, 2)
  
  @@map("transaction_items")
}
```

### Migrasi
```bash
npx prisma migrate dev --name add_transaction_system
```

---

## 3. Implementasi Logic (Service & Controller)

Kita akan memisahkan logic ke dalam **Service** dan **Controller** sesuai struktur project `be/src`.

### A. Service Layer (`src/services/transaction.service.ts`)
Di sini kita menangani logic bisnis dan database transaction.

```ts
import { prisma } from "../prisma"; // Sesuaikan path prisma client
import { Prisma } from "@prisma/client";

export const checkout = async (userId: number, items: { productId: number; quantity: number }[]) => {
  return await prisma.$transaction(async (tx) => {
    let total = 0;
    const transactionItemsData = [];

    // 1. Loop setiap item untuk ambil data Product asli (Harga & Stok)
    for (const item of items) {
      const product = await tx.product.findUnique({
        where: { id: item.productId }
      });

      if (!product) {
        throw new Error(`Product ID ${item.productId} not found`);
      }

      // Validasi Stok (Optional tapi recommended)
      if (product.stock < item.quantity) {
        throw new Error(`Insufficient stock for product ${product.name}`);
      }

      // Hitung Total (Harga DB x Quantity Request)
      const currentPrice = Number(product.price);
      total += currentPrice * item.quantity;

      // Siapkan data untuk disimpan ke pivot TransactionItem
      transactionItemsData.push({
        productId: item.productId,
        quantity: item.quantity,
        priceAtTime: product.price // PENTING: Simpan harga saat transaksi terjadi
      });

      // Update Stok (Decrement)
      await tx.product.update({
        where: { id: item.productId },
        data: { stock: { decrement: item.quantity } }
      });
    }

    // 2. Buat Header Transaksi & Detail Items sekaligus (Nested Write)
    const newTransaction = await tx.transaction.create({
      data: {
        userId,
        total, // Total hasil perhitungan real
        items: {
          create: transactionItemsData // Insert ke table pivot
        }
      },
      include: {
        items: {
          include: { product: true } // Return response lengkap
        }
      }
    });

    return newTransaction;
  });
};

export const getTransactionById = async (id: number) => {
  return await prisma.transaction.findUnique({
    where: { id },
    include: {
      user: true, // Ambil data user
      items: {    // Ambil data items
        include: {
          product: true // Di dalam item, ambil data produknya (Nested Include)
        }
      }
    }
  });
};
```

### B. Controller Layer (`src/controllers/transaction.controller.ts`)
Controller hanya bertugas menerima request, memanggil service, dan mengembalikan response.

```ts
import { Request, Response } from "express";
import * as transactionService from "../services/transaction.service";

export const checkout = async (req: Request, res: Response) => {
  try {
    const { userId, items } = req.body;
    const result = await transactionService.checkout(userId, items);
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({ message: "Checkout failed" });
  }
};

export const getDetail = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const result = await transactionService.getTransactionById(Number(id));
    if (!result) return res.status(404).json({ message: "Transaction not found" });
    res.json(result);
  } catch (error) {
    res.status(500).json({ message: "Error retrieval" });
  }
};
```

---

## 4. Eager Loading (Penjelasan)

Pada method `getTransactionById` di atas, perhatikan bagian `include`.

```ts
include: {
  user: true, 
  items: {
    include: {
      product: true
    }
  }
}
```

Ini disebut **Eager Loading** atau **Nested Reads**.
1. Kita tarik data `Transaction`.
2. Kita sertakan (`include`) data `User` pembuatnya.
3. Kita sertakan `items` (daftar barang yg dibeli).
4. Di DALAM `items`, kita sertakan lagi detail `Product`-nya (seperti nama barang).

Hasil JSON-nya akan berbentuk hirarki lengkap (Tree Structure).

---

## 5. Tugas Harian Hari Ke-13

**Misi:** Buat fitur Checkout menggunakan struktur folder `be/src`.

1.  **Schema:** Implementasikan relasi N-N di `schema.prisma`.
2.  **Files:**
    - Buat `src/services/transaction.service.ts`
    - Buat `src/controllers/transaction.controller.ts`
    - Buat route baru di `src/routes/transaction.routes.ts` (atau gabung di index sementara).
3.  **Endpoint:**
    - `POST /api/transactions` (Checkout)
    - `GET /api/transactions/:id` (Detail Transaksi)
4.  **Testing:** Gunakan Postman untuk simulasi checkout dengan beberapa item sekaligus.

**Checklist:**
- [ ] Schema N-N (via pivot) terbentuk.
- [ ] Logic tersimpan rapi di Service & Controller (bukan di index/route).
- [ ] Transaksi atomic berfungsi (pakai `$transaction`).
- [ ] Bisa melihat detail transaksi lengkap dengan nama produk.

---

**Tips:** Pisahkan logic database (Prisma) dari logic HTTP (Req/Res) agar kodemu rapi dan mudah di-test. ðŸ’°
