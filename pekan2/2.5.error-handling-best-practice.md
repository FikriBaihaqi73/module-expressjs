# Pekan 2 - Hari 11: Error Handling & Best Practice Prisma

**HARI KE-11** ‚Äì Aplikasi yang Tangguh (Robust)
**Fokus hari ini:** Menangani error dengan elegan dan menulis kode Prisma yang efisien.

---

## 1. Centralized Error Handling

Jangan biarkan aplikasi crash atau loading terus saat error. Kita butuh mekanisme penanganan error terpusat.

### Middleware Error Handler
Buat di `src/index.ts` (paling bawah, sebelum `app.listen`).

```ts
// Middleware Error
app.use((err: any, req: Request, res: Response, next: NextFunction) => {
  console.error(err.stack); // Log error di server

  // Cek tipe error
  res.status(500).json({
    success: false,
    message: "Terjadi kesalahan pada server",
    error: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});
```

### Try-Catch Wrapper (Async Handler)
Supaya tidak perlu tulis `try-catch` di setiap route, kita bisa buat wrapper function. Atau gunakan library `express-async-errors`.

```bash
npm install express-async-errors
```
Import di paling atas `index.ts`:
```ts
import 'express-async-errors';
```
Sekarang kalau ada error di async function, otomatis masuk ke Error Middleware di atas!

---

## 2. Menangani Error Spesifik Prisma

Prisma punya kode error unik. Contoh: `P2002` (Unique Constraint Violation / Data Kembar).

Update Error Middleware kita:
```ts
import { Prisma } from '@prisma/client';

app.use((err: any, req: Request, res: Response, next: NextFunction) => {
  
  // Handle Error Prisma
  if (err instanceof Prisma.PrismaClientKnownRequestError) {
    if (err.code === 'P2002') {
      return res.status(400).json({
        success: false,
        message: "Data sudah ada (Unique constraint violation)",
        field: err.meta?.target
      });
    }
    if (err.code === 'P2025') {
      return res.status(404).json({
        success: false,
        message: "Data tidak ditemukan"
      });
    }
  }

  // Handle Error Validasi / Umum
  res.status(500).json({ success: false, message: err.message });
});
```

---

## 3. Soft Delete (Menghapus Tanpa Menghilangkan)

Di dunia nyata, data jarang benar-benar dihapus (Hard Delete) untuk keperluan audit/history. Kita pakai **Soft Delete**.

### Update Schema
Tambahkan kolom `deletedAt`.
```prisma
model Product {
  // ... field lain
  deletedAt DateTime? // Kalau null berarti aktif, kalau ada tanggal berarti dihapus
}
```

### Implementasi
**Delete:** Jangan `delete()`, tapi `update()`.
```ts
await prisma.product.update({
  where: { id: 1 },
  data: { deletedAt: new Date() }
});
```

**Read:** Filter yang `deletedAt` nya null.
```ts
await prisma.product.findMany({
  where: { deletedAt: null }
});
```

---

## 4. Tugas Harian Hari Ke-11

**Misi:** Bikin API kamu "Anti-Crash" dan support Soft Delete.

1.  **Install `express-async-errors`:** Implementasikan di project.
2.  **Global Error Handler:** Buat middleware error di akhir file.
3.  **Handle Duplicate:** Coba insert Kategori dengan nama yang sama (pastikan field `name` di schema `@unique`). Pastikan response-nya rapi (400 Bad Request), bukan error HTML panjang.
4.  **Soft Delete:**
    - Tambah kolom `deletedAt` di Product.
    - Ubah endpoint DELETE menjadi Soft Delete.
    - Ubah endpoint GET agar tidak menampilkan produk yang sudah dihapus.

**Checklist:**
- [ ] Aplikasi tidak crash saat terjadi error database.
- [ ] Pesan error user-friendly (JSON).
- [ ] Soft delete berfungsi (data masih ada di DB tapi ada tanggal deletedAt).
- [ ] Get Products bersih dari barang yang dihapus.

---

**Tips:** Error handling membedakan aplikasi amatir dan profesional. User tidak perlu tahu detail error teknis, tapi developer butuh log-nya. üõ°Ô∏è
