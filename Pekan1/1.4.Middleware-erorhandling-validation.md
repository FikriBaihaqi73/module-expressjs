**pekan-1/hari-4.md**  
**HARI KE-4**  
**Topik Harian:** Middleware, Error Handling, dan Validasi Input  
**Kompetensi:** Santri dapat menerapkan middleware, error handler, dan validasi input  
**Indikator Penilaian:** Santri mampu mengelola middleware, menangani error dengan rapi, dan memvalidasi input request.  
**Alokasi Waktu:** 10 jam  

### MATERI HARI KE-4 – API LEBIH KOKOH!

Pada hari ini, kita akan fokus pada bagaimana membuat API kita lebih kokoh dan aman.
Kita tetap satu file `src/index.ts`, tapi kita tambah 5 hal penting:

1. Middleware logging (morgan)
2. Custom middleware
3. Global Error Handler (supaya error tidak crash server + response rapi)
4. Async Handler (biar nanti pas pakai database tidak pusing try-catch)
5. Validasi Input Request (dengan `express-validator`) + Response Formatter

### 1. Install Package Tambahan

```bash
npm install morgan helmet cors express-validator
npm install -D @types/morgan @types/cors @types/express-validator
```

### 2. Kode Lengkap Hari 4 (src/index.ts)  
**Copy dulu sebagai contoh, lalu kamu kembangkan sendiri di tugas!**

```ts
import express, { Request, Response, NextFunction } from 'express';
import dotenv from 'dotenv';
import morgan from 'morgan';
import helmet from 'helmet';
import cors from 'cors';
import { body, param, query, validationResult } from 'express-validator';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// ==================== MIDDLEWARE ====================

// `helmet()`: Membantu mengamankan aplikasi Express dengan mengatur berbagai HTTP headers.
//             Ini melindungi dari beberapa kerentanan web yang diketahui seperti XSS.
app.use(helmet());                    // keamanan header
// `cors()`: Memungkinkan atau membatasi resource di server agar dapat diakses oleh domain lain (Cross-Origin Resource Sharing).
//           Sangat penting untuk API yang akan diakses oleh frontend dari domain berbeda.
app.use(cors());                      // biar bisa diakses dari frontend
// `morgan('dev')`: Middleware logging HTTP request. Format 'dev' memberikan output yang ringkas dan berwarna,
//                 sangat berguna saat pengembangan untuk melihat request yang masuk dan status responsnya.
app.use(morgan('dev'));               // logger cantik di terminal
app.use(express.json());              // baca body JSON

// ====== CUSTOM MIDDLEWARE ======
// Custom middleware adalah fungsi JavaScript yang memiliki akses ke objek request (req),
// objek response (res), dan fungsi middleware berikutnya dalam siklus request-response (next).
// Mereka dapat mengeksekusi kode apa pun, membuat perubahan pada objek request dan response,
// mengakhiri siklus request-response, atau memanggil middleware berikutnya.

// Custom Middleware – Tambah timestamp ke setiap request
app.use((req: Request, res: Response, next: NextFunction) => {
  console.log(`Request masuk: ${req.method} ${req.path}`);
  (req as any).startTime = Date.now();
  next();
});

// Custom Middleware – Cek apakah ada header X-Nama-Santri
app.use((req: Request, res: Response, next: NextFunction) => {
  const nama = req.headers['x-nama-santri'];
  if (!nama) {
    return res.status(400).json({
      success: false,
      message: "Header X-Nama-Santri wajib diisi ya!"
    });
  }
  (req as any).namaSantri = nama;
  next();
});

// ==================== DATA BUKU (sambung dari Hari 2) ====================
// `interface Buku`: Mendefinisikan struktur atau 'kontrak' untuk objek buku.
//                  Ini sangat berguna di TypeScript untuk memastikan semua objek buku memiliki properti
//                  `id`, `judul`, `penulis`, dan `harga` dengan tipe data yang sesuai, 
//                  sehingga mencegah bug terkait tipe data saat pengembangan.
interface Buku {
  id: number;
  judul: string;
  penulis: string;
  harga: number;
}

let books: Buku[] = [
  { id: 1, judul: "Belajar Node.js", penulis: "Ahmad", harga: 75000 },
  { id: 2, judul: "TypeScript untuk Pemula", penulis: "Siti", harga: 90000 },
  { id: 3, judul: "Express.js dari Nol", penulis: "Budi", harga: 120000 }
];

// ==================== RESPONSE HELPER ====================
// Response helpers ini dibuat untuk memastikan semua respons API memiliki format yang konsisten (misalnya, selalu ada `success`, `message`, dan `data`/`errors`).
// Ini memudahkan klien API untuk memproses respons dan meningkatkan pengalaman developer saat mengonsumsi API kita.

// Success Response Helper
const successResponse = (
  res: Response,
  message: string,
  data: any = null,
  pagination: any = null,
  statusCode: number = 200
) => {
  const response: any = {
    success: true,
    message,
  };

  if (data !== null) response.data = data;
  if (pagination) response.pagination = pagination;

  return res.status(statusCode).json(response);
};

// Error Response Helper
const errorResponse = (
  res: Response,
  message: string,
  statusCode: number = 400,
  errors: any = null
) => {
  const response: any = {
    success: false,
    message,
  };

  if (errors) response.errors = errors;

  return res.status(statusCode).json(response);
};

// ==================== VALIDASI INPUT DENGAN EXPRESS-VALIDATOR ====================
// `express-validator` adalah middleware yang sangat kuat untuk memvalidasi data input dari request.
// Alur kerjanya biasanya: definisi aturan validasi -> menjalankan validasi di middleware -> memeriksa hasil validasi.
// Jika ada error validasi, kita bisa mengembalikan respons error yang rapi.

const validate = (validations: any[]) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    await Promise.all(validations.map(validation => validation.run(req)));

    const errors = validationResult(req);
    if (errors.isEmpty()) {
      return next();
    }

    const errorList = errors.array().map(err => ({
      field: err.param,
      message: err.msg
    }));

    return errorResponse(res, 'Validasi gagal', 400, errorList);
  };
};

// Validasi untuk CREATE & UPDATE buku
const createBookValidation = [
  body('judul')
    .trim()
    .notEmpty().withMessage('Judul wajib diisi')
    .isLength({ min: 3 }).withMessage('Judul minimal 3 karakter'),
  
  body('penulis')
    .trim()
    .notEmpty().withMessage('Penulis wajib diisi'),
  
  body('harga')
    .isNumeric().withMessage('Harga harus angka')
    .custom(value => value > 0).withMessage('Harga harus lebih dari 0')
];

// Validasi untuk GET by ID
const getBookByIdValidation = [
  param('id')
    .isNumeric().withMessage('ID harus angka')
];

// ==================== ROUTES (sama seperti Hari 2 + tambahan validasi) ====================

app.get('/', (req: Request, res: Response) => {
  const waktuProses = Date.now() - (req as any).startTime;
  successResponse(res, `Halo ${(req as any).namaSantri}! API Toko Buku – Hari 4`, { // Diubah dari Hari 3 ke Hari 4
    hari: 4, // Diubah dari hari 3 ke hari 4
    status: "Server hidup!"
  }, null, 200);
});

app.get('/api/buku', (req: Request, res: Response) => {
  successResponse(res, 'Daftar buku', books);
});

app.get('/api/buku/:id', validate(getBookByIdValidation), (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  const buku = books.find(b => b.id === id);

  if (!buku) {
    // Kita lempar error → nanti ditangkap global error handler
    throw new Error('Buku dengan ID tersebut tidak ditemukan');
  }

  successResponse(res, 'Buku ditemukan', buku);
});

app.post('/api/buku', validate(createBookValidation), (req: Request, res: Response) => {
  const { judul, penulis, harga } = req.body;

  const bukuBaru: Buku = {
    id: books.length + 1,
    judul,
    penulis,
    harga: Number(harga)
  };

  books.push(bukuBaru);

  successResponse(res, 'Buku berhasil ditambahkan', bukuBaru, null, 201);
});

// ==================== ERROR HANDLING ====================

// `asyncHandler`: Ini adalah fungsi *wrapper* yang gunanya adalah untuk menangani Promise yang di-reject
//                 (misalnya, karena error pada operasi database asynchronous) dan meneruskannya ke global error handler secara otomatis.
//                 Dengan ini, kita tidak perlu menulis `try-catch` di setiap *route handler* yang asinkron, 
//                 membuat kode lebih bersih dan mengurangi redundansi.
const asyncHandler = (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    // Promise.resolve digunakan untuk memastikan fungsi fn yang dijalankan selalu mengembalikan Promise.
    // Ini penting agar .catch(next) dapat menangkap error yang terjadi, baik dari fungsi async
    // maupun fungsi synchronous yang melempar error. Tanpa asyncHandler, setiap fungsi controller
    // yang bersifat async dan berpotensi melempar error perlu dibungkus dengan try-catch manual.
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

// Contoh route async (nanti dipakai pas Sequelize)
app.get('/api/test-async', asyncHandler(async (req: Request, res: Response) => {
  await new Promise(resolve => setTimeout(resolve, 100));
  successResponse(res, "Async berhasil!");
}));

// 404 Handler: Middleware ini harus diletakkan PALING AKHIR di antara semua route dan middleware lainnya.
//              Ini karena Express akan memproses request secara berurutan. Jika suatu request 
//              tidak cocok dengan route atau middleware sebelumnya, maka request tersebut 
//              akan mencapai handler ini, yang berarti route yang diakses tidak ditemukan.
app.use('*', (req: Request, res: Response) => {
  throw new Error(`Route ${req.originalUrl} tidak ada bro`);
});

// Global Error Handler – INI YANG PALING PENTING HARI INI
// Middleware ini memiliki empat parameter (`err`, `req`, `res`, `next`), yang menandakan bahwa ini adalah error handling middleware.
// Express akan secara otomatis memanggil middleware ini ketika ada error yang terjadi
// di salah satu route atau middleware sebelumnya (misalnya, dari `throw new Error()` atau Promise yang di-reject).
// Ini adalah tempat sentral untuk mengelola semua error, mencegah server crash, 
// dan mengirimkan respons error yang konsisten kepada klien.
app.use((err: any, req: Request, res: Response, next: NextFunction) => {
  console.error('ERROR:', err.message);

  // Kalau error validasi dari express-validator sudah ditangani di `validate` middleware.
  // Ini untuk error umum lain atau error yang kita `throw` manual.
  const statusCode = err.message.includes('tidak ditemukan') ? 404 : 400;

  errorResponse(res, err.message || 'Terjadi kesalahan server', statusCode, 
    process.env.NODE_ENV === 'development' ? { stack: err.stack } : null
  );
});

app.listen(PORT, () => {
  console.log(`Server HARI 4 jalan di http://localhost:${PORT}`); // Diubah dari Hari 3 ke Hari 4
  console.log(`Jangan lupa kirim header: X-Nama-Santri: NamaKamu`);
});
```

### TUGAS HARIAN HARI KE-4 (KERJAKAN SENDIRI!)

Kembangkan API Toko Buku kamu dari Hari 3 jadi seperti ini: // Diubah dari Hari 2 ke Hari 3

1.  Tambahkan **morgan**, **helmet**, **cors**
2.  Buat **2 custom middleware**:
    *   Yang cek header `X-Nama-Santri` (wajib ada)
    *   Yang hitung berapa milidetik proses request (tampilkan di response)
3.  Semua error (buku tidak ada, field kurang, route salah) harus:
    *   Lempar dengan `throw new Error("pesan")`
    *   Harus ditangkap global error handler → return JSON rapi
4.  Tambahkan route baru:
    *   `GET /api/error-test` → sengaja lempar error
    *   `GET /api/async-test` → pakai asyncHandler
5.  **Integrasikan Validasi Input dengan `express-validator`** untuk `POST /api/buku` dan `GET /api/buku/:id`.
6.  **Gunakan `successResponse` dan `errorResponse`** untuk semua respons API.

### Checklist Penilaian Hari Ke-4 (Centang semua!)

*   [ ] `morgan` muncul log warna-warni di terminal
*   [ ] Kalau tidak kirim header `X-Nama-Santri` → error 400
*   [ ] Buka route yang salah → error 404 rapi
*   [ ] Cari buku ID 999 → error 404 rapi
*   [ ] POST tanpa judul (atau dengan harga <= 0) → error 400 rapi dengan detail validasi
*   [ ] GET `/api/buku/abc` → error 400 karena ID bukan angka
*   [ ] Ada waktu proses di setiap response (optional, bisa di `successResponse`)
*   [ ] Semua response pakai `successResponse` / `errorResponse`
*   [ ] Commit message: `"Hari 4: Middleware + Global Error Handler + Async Handler + Validasi"` // Diubah dari Hari 3 ke Hari 4

### Bonus (Kalau Cepat)

*   Buat validasi untuk `query` di `GET /api/buku` (misal `page`, `limit`).
*   Batasi request (max 10 per menit) – pakai variabel sederhana.

**Besok Hari Ke-5 kita pisah ke struktur MVC (routes, controllers, dll)** // Diubah dari Hari 4 ke Hari 5

Santai aja, hari ini fokusnya:  
**“Membangun API yang kuat dengan Middleware, Error Handling, dan Validasi”** // Diubah dari kalimat sebelumnya

Kerjakan tugas ini sampai benar-benar mengerti.  
Kalau sudah selesai, push ke GitHub + kirim link repo ke grup.

**Semangat santri! Hari ini kamu jadi jauh lebih pro & API kamu makin kokoh!**
