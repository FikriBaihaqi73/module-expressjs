**pekan-1/hari-5.md**  
**HARI KE-5**  
**Topik Harian:** Struktur MVC dan REST API  
**Kompetensi (sesuai silabus):** Santri dapat menerapkan arsitektur MVC dalam aplikasi REST API  
**Indikator Penilaian:** Santri mampu mengimplementasikan struktur proyek berbasis MVC + pemisahan Controller & Service 
**Alokasi Waktu:** 10 jam  

Hari ini kita **REFACTOR TOTAL** proyek E-Commerce dari Hari 1–3 menjadi struktur MVC + Service yang bersih dan scalable!

### Mengapa Struktur MVC + Service Layer Penting?

Dengan memisahkan `Controller` (menangani request/response), `Service` (menangani logika bisnis), dan `Route` (mendefinisikan endpoint), kita mendapatkan beberapa manfaat utama:
1.  **Keterbacaan dan Keteraturan Kode**: Kode menjadi lebih mudah dibaca dan dipahami karena setiap bagian memiliki tanggung jawab yang jelas.
2.  **Kemudahan Pemeliharaan (Maintainability)**: Perubahan pada logika bisnis tidak akan mempengaruhi bagian routing atau controller secara langsung, membuat pemeliharaan lebih mudah.
3.  **Skalabilitas**: Aplikasi lebih mudah dikembangkan dan ditambahkan fitur baru karena setiap komponen dapat dimodifikasi atau diganti tanpa mempengaruhi bagian lain secara drastis.
4.  **Uji Coba (Testability)**: Logika bisnis di Service Layer menjadi lebih mudah untuk diuji secara independen, tanpa perlu menjalankan seluruh server atau controller.
5.  **Kolaborasi Tim**: Dalam tim pengembangan, setiap anggota bisa fokus pada lapisan yang berbeda tanpa banyak konflik.

### Struktur Folder Akhir Hari Ke-4 (WAJIB seperti ini!)

```
src/
├── controllers/      ← Menangani request HTTP masuk dan mengirimkan response. Berinteraksi dengan service layer.
│   └── productController.ts
├── services/         ← Berisi logika bisnis utama aplikasi. Berinteraksi dengan database (atau data in-memory di sini).
│   └── productService.ts
├── routes/           ← Mendefinisikan endpoint API dan menghubungkannya ke controller yang relevan.
│   └── productRoutes.ts
├── models/           ← Berisi definisi struktur data (interface/class) atau interaksi langsung dengan database (ORM).
│   └── productModel.ts
├── types/            ← Berisi definisi tipe TypeScript global atau custom yang digunakan di seluruh aplikasi.
│   └── express.d.ts
├── middlewares/      ← Fungsi-fungsi yang dijalankan sebelum atau sesudah route handler utama (misal: error handling, auth).
│   └── errorHandler.ts
├── utils/            ← Berisi fungsi-fungsi utilitas atau helper yang digunakan di berbagai tempat (misal: asyncHandler).
│   └── asyncHandler.ts
├── app.ts            ← Menginisialisasi aplikasi Express, mendaftarkan middleware dan routes.
└── index.ts          ← Titik masuk utama aplikasi, memulai server Express dan mengkonfigurasi environment.
```

### 1. Buat Folder & File Baru

```bash
mkdir src/controllers src/services src/routes src/models src/types src/middlewares src/utils
touch src/controllers/productController.ts
touch src/services/productService.ts
touch src/routes/productRoutes.ts
touch src/models/productModel.ts
touch src/types/express.d.ts
touch src/middlewares/errorHandler.ts
touch src/utils/asyncHandler.ts
touch src/app.ts
```

### 2. File-file Inti

// Catatan tentang `import` dan `export`:
// Di dalam struktur MVC ini, kita akan banyak menggunakan `import` dan `export` (ES Modules).
// `export` digunakan untuk membuat fungsi, kelas, atau variabel dapat diakses dari file lain.
// `import` digunakan untuk mengambil (menggunakan) fungsi, kelas, atau variabel yang telah di-export dari file lain.
// Ini adalah inti dari modularitas kode dan memisahkan 'concerns' di setiap lapisan aplikasi.

#### src/types/express.d.ts
// File ini digunakan untuk memperluas (augment) tipe `Request` bawaan dari Express.
// Karena kita menambahkan properti kustom seperti `startTime` dan `namaSantri` ke objek `req`
// di middleware, TypeScript perlu tahu tentang properti-properti ini agar tidak mengeluh error.
// `declare global` dan `namespace Express` memungkinkan kita melakukan ini dengan aman.
```ts
import { Request } from 'express';

declare global {
  namespace Express {
    interface Request {
      startTime?: number;
      namaSantri?: string;
    }
  }
}
```

#### src/utils/asyncHandler.ts
```ts
import { Request, Response, NextFunction } from 'express';

export const asyncHandler = (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};
```

#### src/services/productService.ts (BUSINESS LOGIC DI SINI!)
```ts
// Ini yang nanti akan diganti Sequelize
interface Product {
  id: number;
  name: string;
  price: number;
  stock: number;
}

let products: Product[] = [
  { id: 1, name: "Laptop Dell XPS 13", price: 12000000, stock: 10 },
  { id: 2, name: "Mouse Logitech MX Master 3", price: 500000, stock: 20 },
  { id: 3, name: "Keyboard Razer Huntsman Elite", price: 1500000, stock: 15 }
];

export class ProductService {
  static getAll() {
    return products;
  }

  static getById(id: number) {
    const product = products.find(p => p.id === id);
    if (!product) throw new Error('Product not found');
    return product;
  }

  static create(data: { name: string; price: number; stock: number }) {
    // Validasi input sekarang ditangani oleh express-validator di layer route/controller (Hari 3),
    // sehingga tidak perlu validasi manual di Service Layer.
    const productBaru = {
      id: products.length + 1,
      ...data
    };
    products.push(productBaru);
    return productBaru;
  }

  static update(id: number, data: Partial<Product>) {
    // `Partial<Product>` adalah utilitas tipe dari TypeScript yang membuat semua properti
    // dari `Product` menjadi opsional. Ini sangat cocok untuk operasi `update` 
    // di mana kita mungkin hanya ingin mengubah sebagian properti dari objek product,
    // bukan seluruh objek.
    const index = products.findIndex(p => p.id === id);
    if (index === -1) throw new Error('Product not found');
    products[index] = { ...products[index], ...data };
    return products[index];
  }

  static delete(id: number) {
    const index = products.findIndex(p => p.id === id);
    if (index === -1) throw new Error('Product not found');
    return products.splice(index, 1)[0];
  }
}
```

#### src/controllers/productController.ts (HANYA TERIMA REQUEST & KIRIM RESPONSE)
```ts
import { Request, Response } from 'express';
import { ProductService } from '../services/productService';
import { asyncHandler } from '../utils/asyncHandler';

// Import response helpers (jika belum ada, bisa ditambahkan dari Hari 3)
// import { successResponse, errorResponse } from '../utils/responses';

// Import validasi dari Hari 3 (jika belum ada, bisa ditambahkan)
// import { validate, createBookValidation, getBookByIdValidation } from '../validations/bookValidation';

**Penjelasan Controller:**
Controller adalah lapisan yang berinteraksi langsung dengan HTTP request dan response. 
Tugas utamanya adalah menerima input dari klien, meneruskan ke Service Layer untuk diproses, 
dan mengembalikan hasil ke klien. Controller **tidak boleh** mengandung logika bisnis (seperti manipulasi data langsung);
itu adalah tanggung jawab Service Layer.
```ts
import { Request, Response } from 'express';
import { ProductService } from '../services/productService';
import { asyncHandler } from '../utils/asyncHandler';

// Import response helpers (jika belum ada, bisa ditambahkan dari Hari 3)
// import { successResponse, errorResponse } from '../utils/responses';

// Import validasi dari Hari 3 (jika belum ada, bisa ditambahkan)
// import { validate, createBookValidation, getBookByIdValidation } from '../validations/bookValidation';

export const getAllProducts = asyncHandler(async (req: Request, res: Response) => {
  const products = ProductService.getAll();
  // Gunakan successResponse dari Hari 3 jika sudah diimplementasikan
  res.json({
    success: true,
    count: products.length,
    data: products
  });
});

export const getProductById = asyncHandler(async (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  const product = ProductService.getById(id);
  // Gunakan successResponse dari Hari 3 jika sudah diimplementasikan
  res.json({ success: true, data: product });
});

export const createProduct = asyncHandler(async (req: Request, res: Response) => {
  const product = ProductService.create(req.body);
  // Gunakan successResponse dari Hari 3 jika sudah diimplementasikan
  res.status(201).json({
    success: true,
    message: 'Product berhasil ditambahkan',
    data: product
  });
});

export const updateProduct = asyncHandler(async (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  const product = ProductService.update(id, req.body);
  // Gunakan successResponse dari Hari 3 jika sudah diimplementasikan
  res.json({
    success: true,
    message: 'Product berhasil diupdate',
    data: product
  });
});

export const deleteProduct = asyncHandler(async (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  const product = ProductService.delete(id);
  // Gunakan successResponse dari Hari 3 jika sudah diimplementasikan
  res.json({
    success: true,
    message: 'Product berhasil dihapus',
    data: product
  });
});
```

#### src/routes/productRoutes.ts
```ts
import { Router } from 'express';
import {
  getAllProducts,
  getProductById,
  createProduct,
  updateProduct,
  deleteProduct
} from '../controllers/productController';

// Import response helpers dan validasi dari Hari 3 (jika sudah ada)
// import { validate, createBookValidation, getBookByIdValidation } from '../validations/bookValidation';

const router = Router();

// Tambahkan validasi ke route di sini jika ingin diterapkan langsung di router level
router.get('/', getAllProducts);
router.get('/:id', getProductById);
router.post('/', createProduct);
router.put('/:id', updateProduct);
router.delete('/:id', deleteProduct);

export default router;
```

#### Pemisahan `app.ts` dan `index.ts`:
Pemisahan ini adalah praktik terbaik untuk aplikasi Express.
`app.ts` berisi konfigurasi aplikasi Express (middleware, routes, error handling) 
tetapi tidak memulai server. Ini memungkinkan `app` di-*export* dan digunakan 
untuk tujuan pengujian (menjalankan tes tanpa harus memulai server HTTP yang sebenarnya).
`index.ts` adalah file utama yang bertanggung jawab untuk mengimpor aplikasi (`app`) 
dan memulai server HTTP, biasanya juga memuat konfigurasi lingkungan (`dotenv`).

#### src/app.ts
```ts
import express from 'express';
import morgan from 'morgan';
import helmet from 'helmet';
import cors from 'cors';
import productRoutes from './routes/productRoutes';
import { errorHandler } from './middlewares/errorHandler';

const app = express();

app.use(helmet());
app.use(cors());
app.use(morgan('dev'));
app.use(express.json());

// Custom middleware (dari Hari 3)
app.use((req, res, next) => {
  req.startTime = Date.now();
  const nama = req.headers['x-nama-santri'] as string;
  if (!nama) return res.status(400).json({ success: false, message: 'Kirim header X-Nama-Santri' });
  req.namaSantri = nama;
  next();
});

// Routes
app.get('/', (req, res) => {
  const waktu = Date.now() - (req.startTime || 0);
  res.json({ message: `Halo ${req.namaSantri}! Hari 4 – MVC + Service`, waktu_proses: `${waktu}ms` });
});

app.use('/api/products', productRoutes);

// Error handler harus di paling bawah!
// Middleware error handling dengan 4 parameter (`err, req, res, next`) harus selalu 
// diletakkan PALING AKHIR di antara semua middleware dan route lainnya. 
// Ini memastikan bahwa semua error dari route atau middleware sebelumnya 
// dapat ditangkap dan diproses secara terpusat.
app.use(errorHandler);

export default app;
```

#### src/middlewares/errorHandler.ts
```
```