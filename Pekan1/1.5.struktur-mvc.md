**pekan-1/hari-5.md**  
**HARI KE-5**  
**Topik Harian:** Struktur MVC dan REST API  
**Kompetensi (sesuai silabus):** Santri dapat menerapkan arsitektur MVC dalam aplikasi REST API  
**Indikator Penilaian:** Santri mampu mengimplementasikan struktur proyek berbasis MVC + pemisahan Controller & Service 
**Alokasi Waktu:** 10 jam  

Hari ini kita **REFACTOR TOTAL** proyek Toko Buku dari Hari 1–3 menjadi struktur MVC + Service yang bersih dan scalable!

### Mengapa Struktur MVC + Service Layer Penting?

Dengan memisahkan `Controller` (menangani request/response), `Service` (menangani logika bisnis), dan `Route` (mendefinisikan endpoint), kita mendapatkan beberapa manfaat utama:
1.  **Keterbacaan dan Keteraturan Kode**: Kode menjadi lebih mudah dibaca dan dipahami karena setiap bagian memiliki tanggung jawab yang jelas.
2.  **Kemudahan Pemeliharaan (Maintainability)**: Perubahan pada logika bisnis tidak akan mempengaruhi bagian routing atau controller secara langsung, membuat pemeliharaan lebih mudah.
3.  **Skalabilitas**: Aplikasi lebih mudah dikembangkan dan ditambahkan fitur baru karena setiap komponen dapat dimodifikasi atau diganti tanpa mempengaruhi bagian lain secara drastis.
4.  **Uji Coba (Testability)**: Logika bisnis di Service Layer menjadi lebih mudah untuk diuji secara independen, tanpa perlu menjalankan seluruh server atau controller.
5.  **Kolaborasi Tim**: Dalam tim pengembangan, setiap anggota bisa fokus pada lapisan yang berbeda tanpa banyak konflik.

### Struktur Folder Akhir Hari Ke-4 (WAJIB seperti ini!)

```
src/
├── controllers/      ← Menangani request HTTP masuk dan mengirimkan response. Berinteraksi dengan service layer.
│   └── bookController.ts
├── services/         ← Berisi logika bisnis utama aplikasi. Berinteraksi dengan database (atau data in-memory di sini).
│   └── bookService.ts
├── routes/           ← Mendefinisikan endpoint API dan menghubungkannya ke controller yang relevan.
│   └── bookRoutes.ts
├── types/            ← Berisi definisi tipe TypeScript global atau custom yang digunakan di seluruh aplikasi.
│   └── express.d.ts
├── middlewares/      ← Fungsi-fungsi yang dijalankan sebelum atau sesudah route handler utama (misal: error handling, auth).
│   └── errorHandler.ts
├── utils/            ← Berisi fungsi-fungsi utilitas atau helper yang digunakan di berbagai tempat (misal: asyncHandler).
│   └── asyncHandler.ts
├── app.ts            ← Menginisialisasi aplikasi Express, mendaftarkan middleware dan routes.
└── index.ts          ← Titik masuk utama aplikasi, memulai server Express dan mengkonfigurasi environment.
```

### 1. Buat Folder & File Baru

```bash
mkdir src/controllers src/services src/routes src/types src/middlewares src/utils
touch src/controllers/bookController.ts
touch src/services/bookService.ts
touch src/routes/bookRoutes.ts
touch src/types/express.d.ts
touch src/middlewares/errorHandler.ts
touch src/utils/asyncHandler.ts
touch src/app.ts
```

### 2. File-file Inti

// Catatan tentang `import` dan `export`:
// Di dalam struktur MVC ini, kita akan banyak menggunakan `import` dan `export` (ES Modules).
// `export` digunakan untuk membuat fungsi, kelas, atau variabel dapat diakses dari file lain.
// `import` digunakan untuk mengambil (menggunakan) fungsi, kelas, atau variabel yang telah di-export dari file lain.
// Ini adalah inti dari modularitas kode dan memisahkan 'concerns' di setiap lapisan aplikasi.

#### src/types/express.d.ts
// File ini digunakan untuk memperluas (augment) tipe `Request` bawaan dari Express.
// Karena kita menambahkan properti kustom seperti `startTime` dan `namaSantri` ke objek `req`
// di middleware, TypeScript perlu tahu tentang properti-properti ini agar tidak mengeluh error.
// `declare global` dan `namespace Express` memungkinkan kita melakukan ini dengan aman.
```ts
import { Request } from 'express';

declare global {
  namespace Express {
    interface Request {
      startTime?: number;
      namaSantri?: string;
    }
  }
}
```

#### src/utils/asyncHandler.ts
```ts
import { Request, Response, NextFunction } from 'express';

export const asyncHandler = (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};
```

#### src/services/bookService.ts (BUSINESS LOGIC DI SINI!)
```ts
// Ini yang nanti akan diganti Sequelize
interface Buku {
  id: number;
  judul: string;
  penulis: string;
  harga: number;
}

let books: Buku[] = [
  { id: 1, judul: "Belajar Node.js", penulis: "Ahmad", harga: 75000 },
  { id: 2, judul: "TypeScript untuk Pemula", penulis: "Siti", harga: 90000 },
  { id: 3, judul: "Express.js dari Nol", penulis: "Budi", harga: 120000 }
];

export class BookService {
  static getAll() {
    return books;
  }

  static getById(id: number) {
    const buku = books.find(b => b.id === id);
    if (!buku) throw new Error('Buku tidak ditemukan');
    return buku;
  }

  static create(data: { judul: string; penulis: string; harga: number }) {
    // Validasi input sekarang ditangani oleh express-validator di layer route/controller (Hari 3),
    // sehingga tidak perlu validasi manual di Service Layer.
    const bukuBaru = {
      id: books.length + 1,
      ...data
    };
    books.push(bukuBaru);
    return bukuBaru;
  }

  static update(id: number, data: Partial<Buku>) {
    // `Partial<Buku>` adalah utilitas tipe dari TypeScript yang membuat semua properti
    // dari `Buku` menjadi opsional. Ini sangat cocok untuk operasi `update` 
    // di mana kita mungkin hanya ingin mengubah sebagian properti dari objek buku,
    // bukan seluruh objek.
    const index = books.findIndex(b => b.id === id);
    if (index === -1) throw new Error('Buku tidak ditemukan');
    books[index] = { ...books[index], ...data };
    return books[index];
  }

  static delete(id: number) {
    const index = books.findIndex(b => b.id === id);
    if (index === -1) throw new Error('Buku tidak ditemukan');
    return books.splice(index, 1)[0];
  }
}
```

#### src/controllers/bookController.ts (HANYA TERIMA REQUEST & KIRIM RESPONSE)
```ts
import { Request, Response } from 'express';
import { BookService } from '../services/bookService';
import { asyncHandler } from '../utils/asyncHandler';

// Import response helpers (jika belum ada, bisa ditambahkan dari Hari 3)
// import { successResponse, errorResponse } from '../utils/responses';

// Import validasi dari Hari 3 (jika belum ada, bisa ditambahkan)
// import { validate, createBookValidation, getBookByIdValidation } from '../validations/bookValidation';

**Penjelasan Controller:**
Controller adalah lapisan yang berinteraksi langsung dengan HTTP request dan response. 
Tugas utamanya adalah menerima input dari klien, meneruskan ke Service Layer untuk diproses, 
dan mengembalikan hasil ke klien. Controller **tidak boleh** mengandung logika bisnis (seperti manipulasi data langsung);
itu adalah tanggung jawab Service Layer.
```ts
import { Request, Response } from 'express';
import { BookService } from '../services/bookService';
import { asyncHandler } from '../utils/asyncHandler';

// Import response helpers (jika belum ada, bisa ditambahkan dari Hari 3)
// import { successResponse, errorResponse } from '../utils/responses';

// Import validasi dari Hari 3 (jika belum ada, bisa ditambahkan)
// import { validate, createBookValidation, getBookByIdValidation } from '../validations/bookValidation';

export const getAllBooks = asyncHandler(async (req: Request, res: Response) => {
  const books = BookService.getAll();
  // Gunakan successResponse dari Hari 3 jika sudah diimplementasikan
  res.json({
    success: true,
    count: books.length,
    data: books
  });
});

export const getBookById = asyncHandler(async (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  const buku = BookService.getById(id);
  // Gunakan successResponse dari Hari 3 jika sudah diimplementasikan
  res.json({ success: true, data: buku });
});

export const createBook = asyncHandler(async (req: Request, res: Response) => {
  const buku = BookService.create(req.body);
  // Gunakan successResponse dari Hari 3 jika sudah diimplementasikan
  res.status(201).json({
    success: true,
    message: 'Buku berhasil ditambahkan',
    data: buku
  });
});

export const updateBook = asyncHandler(async (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  const buku = BookService.update(id, req.body);
  // Gunakan successResponse dari Hari 3 jika sudah diimplementasikan
  res.json({
    success: true,
    message: 'Buku berhasil diupdate',
    data: buku
  });
});

export const deleteBook = asyncHandler(async (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  const buku = BookService.delete(id);
  // Gunakan successResponse dari Hari 3 jika sudah diimplementasikan
  res.json({
    success: true,
    message: 'Buku berhasil dihapus',
    data: buku
  });
});
```

#### src/routes/bookRoutes.ts
```ts
import { Router } from 'express';
import {
  getAllBooks,
  getBookById,
  createBook,
  updateBook,
  deleteBook
} from '../controllers/bookController';

// Import response helpers dan validasi dari Hari 3 (jika sudah ada)
// import { validate, createBookValidation, getBookByIdValidation } from '../validations/bookValidation';

const router = Router();

// Tambahkan validasi ke route di sini jika ingin diterapkan langsung di router level
router.get('/', getAllBooks);
router.get('/:id', getBookById);
router.post('/', createBook);
router.put('/:id', updateBook);
router.delete('/:id', deleteBook);

export default router;
```

#### Pemisahan `app.ts` dan `index.ts`:
Pemisahan ini adalah praktik terbaik untuk aplikasi Express.
`app.ts` berisi konfigurasi aplikasi Express (middleware, routes, error handling) 
tetapi tidak memulai server. Ini memungkinkan `app` di-*export* dan digunakan 
untuk tujuan pengujian (menjalankan tes tanpa harus memulai server HTTP yang sebenarnya).
`index.ts` adalah file utama yang bertanggung jawab untuk mengimpor aplikasi (`app`) 
dan memulai server HTTP, biasanya juga memuat konfigurasi lingkungan (`dotenv`).

#### src/app.ts
```ts
import express from 'express';
import morgan from 'morgan';
import helmet from 'helmet';
import cors from 'cors';
import bookRoutes from './routes/bookRoutes';
import { errorHandler } from './middlewares/errorHandler';

const app = express();

app.use(helmet());
app.use(cors());
app.use(morgan('dev'));
app.use(express.json());

// Custom middleware (dari Hari 3)
app.use((req, res, next) => {
  req.startTime = Date.now();
  const nama = req.headers['x-nama-santri'] as string;
  if (!nama) return res.status(400).json({ success: false, message: 'Kirim header X-Nama-Santri' });
  req.namaSantri = nama;
  next();
});

// Routes
app.get('/', (req, res) => {
  const waktu = Date.now() - (req.startTime || 0);
  res.json({ message: `Halo ${req.namaSantri}! Hari 4 – MVC + Service`, waktu_proses: `${waktu}ms` });
});

app.use('/api/buku', bookRoutes);

// Error handler harus di paling bawah!
// Middleware error handling dengan 4 parameter (`err, req, res, next`) harus selalu 
// diletakkan PALING AKHIR di antara semua middleware dan route lainnya. 
// Ini memastikan bahwa semua error dari route atau middleware sebelumnya 
// dapat ditangkap dan diproses secara terpusat.
app.use(errorHandler);

export default app;
```

#### src/middlewares/errorHandler.ts
```