**pekan-1/hari-5.md**  
**HARI KE-5**  
**Topik Harian:** Struktur MVC dan REST API  
**Kompetensi (sesuai silabus):** Santri dapat menerapkan arsitektur MVC dalam aplikasi REST API  
**Indikator Penilaian:** Santri mampu mengimplementasikan struktur proyek berbasis MVC + pemisahan Controller & Service 
**Alokasi Waktu:** 10 jam  

Hari ini kita **REFACTOR TOTAL** proyek E-Commerce dari Hari 1–3 menjadi struktur MVC + Service yang bersih dan scalable!

### Mengapa Struktur MVC + Service Layer Penting?

Dengan memisahkan `Controller` (menangani request/response), `Service` (menangani logika bisnis), dan `Route` (mendefinisikan endpoint), kita mendapatkan beberapa manfaat utama:
1.  **Keterbacaan dan Keteraturan Kode**: Kode menjadi lebih mudah dibaca dan dipahami karena setiap bagian memiliki tanggung jawab yang jelas.
2.  **Kemudahan Pemeliharaan (Maintainability)**: Perubahan pada logika bisnis tidak akan mempengaruhi bagian routing atau controller secara langsung, membuat pemeliharaan lebih mudah.
3.  **Skalabilitas**: Aplikasi lebih mudah dikembangkan dan ditambahkan fitur baru karena setiap komponen dapat dimodifikasi atau diganti tanpa mempengaruhi bagian lain secara drastis.
4.  **Uji Coba (Testability)**: Logika bisnis di Service Layer menjadi lebih mudah untuk diuji secara independen, tanpa perlu menjalankan seluruh server atau controller.
5.  **Kolaborasi Tim**: Dalam tim pengembangan, setiap anggota bisa fokus pada lapisan yang berbeda tanpa banyak konflik.

### Struktur Folder Akhir Hari Ke-4 (WAJIB seperti ini!)

```
src/
├── controllers/      ← Menangani request HTTP masuk dan mengirimkan response.
│   └── product.controller.ts
├── services/         ← Berisi logika bisnis utama aplikasi.
│   └── product.service.ts
├── routes/           ← Mendefinisikan endpoint API.
│   └── product.route.ts
├── models/           ← Berisi definisi struktur data.
│   └── product.model.ts
├── types/            ← Definisi tipe TypeScript global.
│   └── express.d.ts
├── middlewares/      ← Middleware (error handling, validation rules).
│   ├── error.handler.ts
│   └── product.validation.ts
├── utils/            ← Fungsi utilitas (async handler, response helper, validation helper).
│   ├── async.handler.ts
│   ├── response.ts
│   └── env.ts
├── app.ts            ← Setup aplikasi Express.
└── index.ts          ← Entry point server.
```

### 1. Buat Folder & File Baru

```bash
mkdir src/controllers src/services src/routes src/models src/types src/middlewares src/utils
touch src/controllers/product.controller.ts
touch src/services/product.service.ts
touch src/routes/product.route.ts
touch src/models/product.model.ts
touch src/types/express.d.ts
touch src/middlewares/error.handler.ts
touch src/middlewares/product.validation.ts
touch src/utils/async.handler.ts
touch src/utils/response.ts
touch src/utils/env.ts
touch src/app.ts
```

### 2. File-file Inti

// Catatan tentang `import` dan `export`:
// Di dalam struktur MVC ini, kita akan banyak menggunakan `import` dan `export` (ES Modules).
// `export` digunakan untuk membuat fungsi, kelas, atau variabel dapat diakses dari file lain.
// `import` digunakan untuk mengambil (menggunakan) fungsi, kelas, atau variabel yang telah di-export dari file lain.
// Ini adalah inti dari modularitas kode dan memisahkan 'concerns' di setiap lapisan aplikasi.

#### src/types/express.d.ts
// File ini digunakan untuk memperluas (augment) tipe `Request` bawaan dari Express.
// Karena kita menambahkan properti kustom seperti `startTime` dan `apiKey` ke objek `req`
// di middleware, TypeScript perlu tahu tentang properti-properti ini agar tidak mengeluh error.
// `declare global` dan `namespace Express` memungkinkan kita melakukan ini dengan aman.
```ts
import { Request } from 'express';

declare global {
  namespace Express {
    interface Request {
      startTime?: number;
      apiKey?: string;
    }
  }
}
```

#### src/utils/async.handler.ts
**Penjelasan:**
`asyncHandler` adalah *Higher-Order Function* yang membungkus fungsi asinkron (seperti controller). Tujuannya adalah untuk menangkap error yang terjadi di dalam Promise (misalnya error database) dan meneruskannya ke `next(err)` agar bisa ditangani oleh Global Error Handler. Tanpa ini, kita harus menulis `try-catch` di setiap controller.

```ts
import { Request, Response, NextFunction } from 'express';

export const asyncHandler = (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};
```

#### src/utils/response.ts
**Penjelasan:**
File ini berisi fungsi helper untuk menstandarisasi format respons API.
- `successResponse`: Digunakan untuk mengirim respons sukses (200, 201) dengan format `{ success: true, message, data }`.
- `errorResponse`: Digunakan untuk mengirim respons error (400, 404, 500) dengan format `{ success: false, message, errors }`.
Konsistensi format respons sangat penting agar frontend mudah mengonsumsi API kita.

```ts
import { Response } from 'express';

interface ApiResponse {
  success: boolean;
  message: string;
  data?: unknown;
  pagination?: {
    page: number;
    limit: number;
    total: number;
  };
  errors?: Array<{
    field: string;
    message: string;
  }> | { stack?: string };
}

export const successResponse = (
  res: Response,
  message: string,
  data: unknown = null,
  pagination: { page: number; limit: number; total: number } | null = null,
  statusCode: number = 200
) => {
  const response: ApiResponse = {
    success: true,
    message,
  };

  if (data !== null) response.data = data;
  if (pagination) response.pagination = pagination;

  return res.status(statusCode).json(response);
};

export const errorResponse = (
  res: Response,
  message: string,
  statusCode: number = 400,
  errors: Array<{ field: string; message: string }> | { stack?: string } | null = null
) => {
  const response: ApiResponse = {
    success: false,
    message,
  };

  if (errors) response.errors = errors;

  return res.status(statusCode).json(response);
};
```

#### src/utils/env.ts
**Penjelasan:**
File ini memusatkan konfigurasi variabel lingkungan (environment variables). Dengan cara ini, kita tidak perlu memanggil `process.env` berulang kali di banyak file, dan kita bisa memberikan nilai default jika variabel tidak ada di `.env`.

```ts
import dotenv from 'dotenv';
dotenv.config();

export const PORT = process.env.PORT || 3000;
export const NODE_ENV = process.env.NODE_ENV || 'development';
```

#### src/models/product.model.ts
// File ini mendefinisikan struktur data untuk produk dan berfungsi sebagai simulasi 'Model' 
// dalam konteks MVC saat kita belum terhubung ke database sungguhan. 
// Ini akan berisi data in-memory atau nanti akan berinteraksi dengan ORM (seperti Sequelize).
```ts
export interface Product {
  id: number;
  nama: string;
  deskripsi: string;
  harga: number;
}

export let products: Product[] = [
  { id: 1, nama: "Laptop Gaming", deskripsi: "Intel i7, RTX 3060", harga: 15000000 },
  { id: 2, nama: "Keyboard Mekanikal", deskripsi: "Blue Switch, RGB", harga: 800000 },
  { id: 3, nama: "Mouse Wireless", deskripsi: "Ergonomic, Silent Click", harga: 300000 }
];
```

#### src/services/product.service.ts (BUSINESS LOGIC DI SINI!)
// Service Layer berisi semua logika bisnis aplikasi. 
// Ia berinteraksi dengan Model (data) dan menyediakan fungsionalitas yang digunakan oleh Controller.
// Di sini kita akan berinteraksi dengan data `products` dari `product.model.ts`.
```ts
import { Product, products } from '../models/product.model';

export class ProductService {
  static getAll(): Product[] {
    return products;
  }

  static getById(id: number): Product {
    const product = products.find(p => p.id === id);
    if (!product) throw new Error('Produk dengan ID tersebut tidak ditemukan');
    return product;
  }

  static create(data: { nama: string; deskripsi: string; harga: number }): Product {
    const newProduct = {
      id: products.length + 1,
      ...data
    };
    products.push(newProduct);
    return newProduct;
  }

  static update(id: number, data: Partial<Product>): Product {
    const index = products.findIndex(p => p.id === id);
    if (index === -1) throw new Error('Produk tidak ditemukan');
    products[index] = { ...products[index], ...data };
    return products[index];
  }

  static delete(id: number): Product {
    const index = products.findIndex(p => p.id === id);
    if (index === -1) throw new Error('Produk tidak ditemukan');
    return products.splice(index, 1)[0];
  }

  // Fitur search yang diminta di tugas
  static search(name?: string, maxPrice?: number): Product[] {
    let result = products;
    if (name) {
      result = result.filter(p => p.nama.toLowerCase().includes(name.toLowerCase()));
    }
    if (maxPrice) {
      result = result.filter(p => p.harga <= maxPrice);
    }
    return result;
  }
}
```

#### src/controllers/product.controller.ts (HANYA TERIMA REQUEST & KIRIM RESPONSE)
**Penjelasan:**
Controller bertugas sebagai "pintu gerbang". Ia menerima `Request` dari router, mengambil data dari `body` atau `params`, lalu menyuruh `Service` untuk melakukan pekerjaan berat (logika bisnis). Setelah `Service` selesai, Controller menggunakan helper `successResponse` untuk mengirimkan hasil kembali ke klien.
**Ingat:** Controller tidak boleh tahu detail database atau logika rumit!

```ts
import { Request, Response } from 'express';
import { ProductService } from '../services/product.service';
import { asyncHandler } from '../utils/async.handler';
import { successResponse } from '../utils/response';

export const getAllProducts = asyncHandler(async (req: Request, res: Response) => {
  const products = ProductService.getAll();
  return successResponse(res, 'Daftar produk', products);
});

export const getProductById = asyncHandler(async (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  const product = ProductService.getById(id);
  return successResponse(res, 'Produk ditemukan', product);
});

export const createProduct = asyncHandler(async (req: Request, res: Response) => {
  const product = ProductService.create(req.body);
  return successResponse(res, 'Produk berhasil ditambahkan', product, null, 201);
});

export const updateProduct = asyncHandler(async (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  const product = ProductService.update(id, req.body);
  return successResponse(res, 'Produk berhasil diupdate', product);
});

export const deleteProduct = asyncHandler(async (req: Request, res: Response) => {
  const id = parseInt(req.params.id);
  const product = ProductService.delete(id);
  return successResponse(res, 'Produk berhasil dihapus', product);
});

export const searchProducts = asyncHandler(async (req: Request, res: Response) => {
  const { name, max_price } = req.query;
  const products = ProductService.search(
    name as string, 
    max_price ? Number(max_price) : undefined
  );
  return successResponse(res, 'Hasil pencarian', products);
});
```

#### src/middlewares/product.validation.ts
**Penjelasan:**
File ini memisahkan logika validasi dari controller.
- `validate`: Middleware pembungkus yang menjalankan aturan validasi dan mengecek apakah ada error. Jika ada, ia langsung mengembalikan respons 400.
- `createProductValidation`: Kumpulan aturan validasi untuk membuat/update produk.
- `getProductByIdValidation`: Aturan validasi untuk memastikan ID adalah angka.

```ts
import { body, param, validationResult, ValidationChain } from 'express-validator';
import { Request, Response, NextFunction } from 'express';
import { errorResponse } from '../utils/response';

// Helper function untuk menjalankan validasi
export const validate = (validations: ValidationChain[]) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    await Promise.all(validations.map(validation => validation.run(req)));

    const errors = validationResult(req);
    if (errors.isEmpty()) {
      return next();
    }

    const errorList = errors.array().map((err: any) => ({
      field: err.path || err.param || 'unknown',
      message: err.msg
    }));

    return errorResponse(res, 'Validasi gagal', 400, errorList);
  };
};

export const createProductValidation = [
  body('nama')
    .trim()
    .notEmpty().withMessage('Nama produk wajib diisi')
    .isLength({ min: 3 }).withMessage('Nama produk minimal 3 karakter'),
  
  body('deskripsi')
    .trim()
    .notEmpty().withMessage('Deskripsi wajib diisi'),
  
  body('harga')
    .isNumeric().withMessage('Harga harus angka')
    .custom(value => value > 0).withMessage('Harga harus lebih dari 0')
];

export const getProductByIdValidation = [
  param('id')
    .isNumeric().withMessage('ID harus angka')
];
```

#### src/routes/product.route.ts
**Penjelasan:**
File ini mendefinisikan URL (endpoint) API kita dan menghubungkannya ke Controller yang sesuai.
Di sini juga kita "menempelkan" middleware validasi sebelum request mencapai Controller.
Contoh: `router.post('/', validate(createProductValidation), createProduct)` artinya "Jika ada POST ke /, jalankan validasi dulu. Kalau lolos, baru jalankan `createProduct`".

```ts
import { Router } from 'express';
import {
  getAllProducts,
  getProductById,
  createProduct,
  updateProduct,
  deleteProduct,
  searchProducts
} from '../controllers/product.controller';
import { 
  validate, 
  createProductValidation, 
  getProductByIdValidation 
} from '../middlewares/product.validation';

const router = Router();

router.get('/', getAllProducts);
router.get('/search', searchProducts); // Route search harus sebelum :id
router.get('/:id', validate(getProductByIdValidation), getProductById);
router.post('/', validate(createProductValidation), createProduct);
router.put('/:id', validate(createProductValidation), updateProduct);
router.delete('/:id', validate(getProductByIdValidation), deleteProduct);

export default router;
```

#### Pemisahan `app.ts` dan `index.ts`:
Pemisahan ini adalah praktik terbaik untuk aplikasi Express.
`app.ts` berisi konfigurasi aplikasi Express (middleware, routes, error handling) 
tetapi tidak memulai server. Ini memungkinkan `app` di-*export* dan digunakan 
untuk tujuan pengujian (menjalankan tes tanpa harus memulai server HTTP yang sebenarnya).
`index.ts` adalah file utama yang bertanggung jawab untuk mengimpor aplikasi (`app`) 
dan memulai server HTTP, biasanya juga memuat konfigurasi lingkungan (`dotenv`).

#### src/app.ts
```ts
import express from 'express';
import morgan from 'morgan';
import helmet from 'helmet';
import cors from 'cors';
import productRoutes from './routes/product.route';
import { errorHandler } from './middlewares/error.handler';

const app = express();

app.use(helmet());
app.use(cors());
app.use(morgan('dev'));
app.use(express.json());

// Custom middleware (dari Hari 4)
app.use((req, res, next) => {
  req.startTime = Date.now();
  const apiKey = req.headers['x-api-key'] as string;
  if (!apiKey) return res.status(401).json({ success: false, message: 'Kirim header X-API-Key' });
  req.apiKey = apiKey;
  next();
});

// Routes
app.get('/', (req, res) => {
  const waktu = Date.now() - (req.startTime || 0);
  res.json({ message: `Halo pemilik API Key: ${req.apiKey}! Hari 5 – MVC E-Commerce + Service`, waktu_proses: `${waktu}ms` });
});

app.use('/api/products', productRoutes);

// Error handler harus di paling bawah!
// Middleware error handling dengan 4 parameter (`err, req, res, next`) harus selalu 
// diletakkan PALING AKHIR di antara semua middleware dan route lainnya. 
// Ini memastikan bahwa semua error dari route atau middleware sebelumnya 
// dapat ditangkap dan diproses secara terpusat.
app.use(errorHandler);

export default app;
```

#### src/middlewares/error.handler.ts
**Penjelasan:**
Ini adalah jaring pengaman terakhir. Jika ada error di mana saja (di Service, Controller, atau Route) yang dilempar dengan `throw` atau `next(err)`, middleware ini yang akan menangkapnya. Ia memastikan user menerima respons JSON yang rapi, bukan halaman error HTML default yang jelek.

```ts
import { Request, Response, NextFunction } from 'express';
import { errorResponse } from '../utils/response';
import { NODE_ENV } from '../utils/env';

export const errorHandler = (err: any, req: Request, res: Response, next: NextFunction) => {
  console.error('ERROR:', err.message);

  const statusCode = err.message.includes('tidak ditemukan') ? 404 : 400;

  errorResponse(res, err.message || 'Terjadi kesalahan server', statusCode, 
    NODE_ENV === 'development' ? { stack: err.stack } : null
  );
};
```

#### src/index.ts
**Penjelasan:**
Ini adalah titik masuk (entry point) aplikasi kita. Tugasnya sangat sederhana: impor aplikasi (`app`) yang sudah dikonfigurasi, lalu jalankan server pada port yang ditentukan.

```ts
import app from './app';
import { PORT } from './utils/env';

app.listen(PORT, () => {
  console.log(`Server MVC + Service E-Commerce jalan di http://localhost:${PORT}`);
});
```

### TUGAS HARIAN HARI KE-5 (KERJAKAN SENDIRI!)

1. Buat struktur folder persis seperti di atas (dengan folder `models`)
2. Pindahkan semua kode dari `src/index.ts` lama ke file-file baru (pastikan middleware, error handling, dan validasi dari Hari 3 sudah terintegrasi ke dalam `app.ts` atau middleware global)
3. Pastikan semua route masih berjalan sama seperti Hari 3 (dengan middleware, error handling, dan validasi yang sudah diintegrasikan)
4. Tambahkan 1 route baru:
   - `GET /api/products/search?nama=...` → cari berdasarkan nama produk (buat di Service!)

### Checklist Penilaian Hari Ke-5

*   [ ] Folder structure MVC + Service + Model sudah rapi
*   [ ] Tidak ada business logic di controller (semua di Service Layer)
*   [ ] Semua route pakai asyncHandler
*   [ ] Error tetap ditangkap rapi (menggunakan global error handler)
*   [ ] Validasi input berfungsi dengan baik (dari Hari 3)
*   [ ] Response API konsisten (menggunakan response helper dari Hari 3)
*   [ ] Bisa search produk berdasarkan nama
*   [ ] Commit message: `"Hari 5: Refactor ke MVC + Service Layer + Model (E-Commerce)"`